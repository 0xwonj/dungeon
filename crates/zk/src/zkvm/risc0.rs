//! RISC0 zkVM prover implementation.
//!
//! This module provides the host-side prover that generates zero-knowledge proofs
//! of game action execution using RISC0's zkVM technology.
//!
//! # Architecture
//!
//! ```text
//! Runtime → Risc0Prover.prove()
//!   ↓
//! ExecutorEnv (oracle_snapshot, before_state, action)
//!   ↓
//! RISC0 zkVM executes guest program
//!   ↓
//! Guest: GameEngine.execute(env, action)
//!   ↓
//! Guest: Commits (after_state, delta, action) to journal
//!   ↓
//! Receipt with proof + journal
//!   ↓
//! Host: Verify consistency (zkVM result == simulation result)
//!   ↓
//! Return ProofData
//! ```
//!
//! # Consistency Verification
//!
//! A critical safety feature: after zkVM execution, we verify that the results
//! (after_state, delta) computed by zkVM match what the simulation worker computed.
//! This catches:
//! - Non-determinism bugs in game logic
//! - Oracle data mismatches
//! - Implementation bugs specific to zkVM environment
//!
//! # Performance
//!
//! - Production mode: 30-60 seconds per proof (with Metal acceleration on macOS)
//! - Development mode (RISC0_DEV_MODE=1): <100ms (skips actual proving)
//!
//! # Environment Variables
//!
//! - `RISC0_DEV_MODE=1`: Enable fast development mode (no real proofs)
//! - `RISC0_PROVER=local`: Force CPU proving
//! - `RISC0_PROVER=bonsai`: Use Bonsai cloud proving service

use risc0_zkvm::{ExecutorEnv, Receipt, default_prover};

use crate::OracleSnapshot;
use crate::prover::{ProofBackend, ProofData, ProofError};
use game_core::{Action, GameState, StateDelta};

// Generated by build.rs - contains ELF and ImageID
use crate::{GAME_VERIFIER_ELF, GAME_VERIFIER_ID};

/// RISC0 zkVM prover implementation.
///
/// This prover generates zero-knowledge proofs of game state transitions
/// using the RISC0 zkVM. It maintains an oracle snapshot for all proofs
/// to avoid re-serializing static content.
///
/// # Design Pattern: Strategy Pattern
///
/// Implements Prover trait for RISC0 zkVM backend.
pub struct Risc0Prover {
    /// Cached oracle snapshot (immutable game content)
    oracle_snapshot: OracleSnapshot,

    /// Whether to verify proofs immediately after generation
    /// (disable for development speed, enable for production safety)
    verify_immediately: bool,
}

impl Risc0Prover {
    /// Creates a new RISC0 prover with oracle snapshot.
    ///
    /// The oracle snapshot is captured once and reused for all subsequent
    /// proofs. This assumes oracle data is immutable during runtime.
    ///
    /// By default, immediate verification is enabled for safety.
    ///
    /// # Arguments
    ///
    /// * `oracle_snapshot` - Serializable snapshot of all oracle data
    pub fn new(oracle_snapshot: OracleSnapshot) -> Self {
        Self {
            oracle_snapshot,
            verify_immediately: true,
        }
    }

    /// Creates a new RISC0 prover with custom verification settings.
    ///
    /// # Arguments
    ///
    /// * `oracle_snapshot` - Serializable snapshot of all oracle data
    /// * `verify_immediately` - Whether to verify proofs immediately after generation
    pub fn with_config(oracle_snapshot: OracleSnapshot, verify_immediately: bool) -> Self {
        Self {
            oracle_snapshot,
            verify_immediately,
        }
    }
}

impl crate::Prover for Risc0Prover {
    fn prove(
        &self,
        before_state: &GameState,
        action: &Action,
        expected_after_state: &GameState,
        _delta: &StateDelta, // Unused in zkVM (guest computes it), but kept for circuit provers
    ) -> Result<ProofData, ProofError> {
        // Build executor environment with inputs
        // Order must match guest's env::read() calls
        let env = ExecutorEnv::builder()
            // 1. Oracle snapshot (static game content)
            .write(&self.oracle_snapshot)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write oracle_snapshot: {}", e)))?
            // 2. Game state before action
            .write(before_state)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write before_state: {}", e)))?
            // 3. Action to execute
            .write(action)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write action: {}", e)))?
            .build()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to build ExecutorEnv: {}", e)))?;

        // Generate proof using RISC0 zkVM
        // Note: Set RISC0_DEV_MODE=1 for fast development mode (skips real proving)
        let prover = default_prover();
        let prove_info = prover
            .prove(env, GAME_VERIFIER_ELF)
            .map_err(|e| ProofError::ZkvmError(format!("Proof generation failed: {}", e)))?;

        let receipt = prove_info.receipt;

        // Optionally verify receipt locally (sanity check)
        // This catches any issues with proof generation immediately.
        // Can be disabled in development mode for faster iteration.
        if self.verify_immediately {
            receipt.verify(GAME_VERIFIER_ID).map_err(|e| {
                ProofError::ZkvmError(format!("Receipt verification failed: {}", e))
            })?;
        }

        // CRITICAL: Verify that zkVM computed the same result as simulation worker
        // This catches non-determinism bugs, oracle mismatches, and implementation bugs
        Self::verify_consistency(&receipt, expected_after_state)?;

        // Serialize receipt for storage/transmission
        let bytes = bincode::serialize(&receipt)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        Ok(ProofData {
            bytes,
            backend: ProofBackend::Risc0,
        })
    }

    fn verify(&self, proof: &ProofData) -> Result<bool, ProofError> {
        // Verify backend matches
        if proof.backend != ProofBackend::Risc0 {
            return Err(ProofError::ZkvmError(format!(
                "Expected Risc0 backend, got {:?}",
                proof.backend
            )));
        }

        // Deserialize receipt
        let receipt: Receipt = bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        // Verify receipt against ImageID
        receipt
            .verify(GAME_VERIFIER_ID)
            .map_err(|e| ProofError::ZkvmError(format!("Verification failed: {}", e)))?;

        Ok(true)
    }
}

impl Risc0Prover {
    /// Verifies that zkVM-computed results match simulation worker results.
    ///
    /// This is a critical safety check that catches:
    /// - Non-determinism bugs in game logic
    /// - Oracle data mismatches between simulation and proving
    /// - Implementation bugs that only manifest in zkVM environment
    ///
    /// # Design Note
    ///
    /// We only need to compare `after_state`. If after_state matches, then by
    /// definition the delta must also match (since delta is deterministically
    /// derived from the state transition). Comparing delta would be redundant.
    ///
    /// # Arguments
    ///
    /// * `receipt` - zkVM receipt containing journal with computed results
    /// * `expected_after_state` - State computed by simulation worker
    ///
    /// # Errors
    ///
    /// Returns `ProofError::StateInconsistency` if zkVM results don't match.
    fn verify_consistency(
        receipt: &Receipt,
        expected_after_state: &GameState,
    ) -> Result<(), ProofError> {
        // Extract after_state from zkVM journal
        // Journal order: [after_state, delta, action]
        let zkvm_after_state: GameState = receipt.journal.decode().map_err(|e| {
            ProofError::SerializationError(format!("Failed to decode zkVM after_state: {}", e))
        })?;

        // Compare after_state (this implicitly validates delta too)
        if &zkvm_after_state != expected_after_state {
            return Err(ProofError::StateInconsistency(format!(
                "zkVM computed different after_state than simulation worker. \
                 This indicates non-determinism or oracle mismatch. \
                 zkVM clock={}, simulation clock={}",
                zkvm_after_state.turn.clock, expected_after_state.turn.clock
            )));
        }

        Ok(())
    }

    /// Decodes a RISC0 receipt from proof data.
    ///
    /// Helper function to avoid duplicating deserialization logic.
    fn decode_receipt(proof: &ProofData) -> Result<Receipt, ProofError> {
        if proof.backend != ProofBackend::Risc0 {
            return Err(ProofError::ZkvmError(format!(
                "Expected Risc0 backend, got {:?}",
                proof.backend
            )));
        }

        bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))
    }

    /// Extracts the resulting GameState from a proof's journal.
    ///
    /// The journal contains public outputs in order:
    /// 1. GameState (after execution)
    /// 2. StateDelta
    /// 3. Action
    pub fn extract_result_state(proof: &ProofData) -> Result<GameState, ProofError> {
        let receipt = Self::decode_receipt(proof)?;

        receipt
            .journal
            .decode()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to decode GameState: {}", e)))
    }

    /// Extracts the StateDelta from a proof's journal.
    pub fn extract_delta(proof: &ProofData) -> Result<StateDelta, ProofError> {
        let receipt = Self::decode_receipt(proof)?;

        // Skip first value (GameState) and decode second value (StateDelta)
        let mut decoder = receipt.journal.bytes.as_slice();
        let _state: GameState = bincode::deserialize_from(&mut decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        bincode::deserialize_from(decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))
    }

    /// Extracts the Action from a proof's journal.
    pub fn extract_action(proof: &ProofData) -> Result<Action, ProofError> {
        let receipt = Self::decode_receipt(proof)?;

        // Skip first two values and decode third value (Action)
        let mut decoder = receipt.journal.bytes.as_slice();
        let _state: GameState = bincode::deserialize_from(&mut decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;
        let _delta: StateDelta = bincode::deserialize_from(&mut decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        bincode::deserialize_from(decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))
    }
}
