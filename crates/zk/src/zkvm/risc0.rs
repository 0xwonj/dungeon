//! RISC0 zkVM prover implementation.
//!
//! Generates zero-knowledge proofs of game action execution using RISC0's zkVM.
//!
//! # Verification Flow
//!
//! 1. Host prepares inputs: oracle snapshot, before_state, action
//! 2. zkVM executes guest program with GameEngine
//! 3. Guest commits: after_state, action to journal (delta computation skipped)
//! 4. Host verifies journal matches expected state
//! 5. Returns proof if consistent, error otherwise
//!
//! # Performance
//!
//! - Production: ~30-60s per proof (with Metal acceleration)
//! - Dev mode (`RISC0_DEV_MODE=1`): <100ms (no real proving)

use risc0_zkvm::{ExecutorEnv, Receipt, default_prover};

use crate::prover::{ProofBackend, ProofData, ProofError};
use crate::{OracleSnapshot, Prover};
use game_core::{Action, GameState};

// Generated by build.rs - contains ELF and ImageID
use crate::{GAME_VERIFIER_ELF, GAME_VERIFIER_ID};

/// RISC0 zkVM prover.
///
/// Maintains a cached oracle snapshot that is reused across all proof generations.
#[derive(Clone)]
pub struct Risc0Prover {
    oracle_snapshot: OracleSnapshot,
}

impl Risc0Prover {
    /// Creates a new RISC0 prover with the given oracle snapshot.
    pub fn new(oracle_snapshot: OracleSnapshot) -> Self {
        Self { oracle_snapshot }
    }
}

impl Prover for Risc0Prover {
    fn prove(
        &self,
        before_state: &GameState,
        action: &Action,
        expected_after_state: &GameState,
    ) -> Result<ProofData, ProofError> {
        // Build executor environment (order must match guest's env::read() calls)
        let env = ExecutorEnv::builder()
            // 1. Oracle snapshot (static game content)
            .write(&self.oracle_snapshot)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write oracle_snapshot: {}", e)))?
            // 2. Game state before action execution
            .write(before_state)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write before_state: {}", e)))?
            // 3. Action to execute
            .write(action)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write action: {}", e)))?
            .build()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to build ExecutorEnv: {}", e)))?;

        // Generate proof
        let prover = default_prover();
        let prove_info = prover
            .prove(env, GAME_VERIFIER_ELF)
            .map_err(|e| ProofError::ZkvmError(format!("Proof generation failed: {}", e)))?;

        let receipt = prove_info.receipt;

        // Verify zkVM-computed result matches expected state
        Self::verify_consistency(&receipt, expected_after_state)?;

        // Serialize receipt for storage/transmission
        let bytes = bincode::serialize(&receipt)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        Ok(ProofData {
            bytes,
            backend: ProofBackend::Risc0,
        })
    }

    fn verify(&self, proof: &ProofData) -> Result<bool, ProofError> {
        // Verify backend matches
        if proof.backend != ProofBackend::Risc0 {
            return Err(ProofError::ZkvmError(format!(
                "Expected Risc0 backend, got {:?}",
                proof.backend
            )));
        }

        // Deserialize receipt
        let receipt: Receipt = bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        // Verify receipt against ImageID
        receipt
            .verify(GAME_VERIFIER_ID)
            .map_err(|e| ProofError::ZkvmError(format!("Verification failed: {}", e)))?;

        Ok(true)
    }
}

impl Risc0Prover {
    /// Verifies zkVM-computed result matches expected state.
    ///
    /// This safety check catches non-determinism bugs, oracle mismatches, and
    /// zkVM-specific implementation issues. Verification happens on the host
    /// for efficiency since journal data is cryptographically committed.
    ///
    /// # Arguments
    ///
    /// * `receipt` - zkVM receipt containing journal with computed results
    /// * `expected_after_state` - State computed by simulation worker
    ///
    /// # Errors
    ///
    /// Returns `ProofError::StateInconsistency` if zkVM results don't match.
    fn verify_consistency(
        receipt: &Receipt,
        expected_after_state: &GameState,
    ) -> Result<(), ProofError> {
        // Extract after_state from zkVM journal
        // Journal order: [after_state, action]
        let zkvm_after_state: GameState = receipt.journal.decode().map_err(|e| {
            ProofError::SerializationError(format!("Failed to decode zkVM after_state: {}", e))
        })?;

        // Compare after_state
        if &zkvm_after_state != expected_after_state {
            return Err(ProofError::StateInconsistency(format!(
                "zkVM computed different after_state than simulation worker. \
                 This indicates non-determinism or oracle mismatch. \
                 zkVM clock={}, simulation clock={}",
                zkvm_after_state.turn.clock, expected_after_state.turn.clock
            )));
        }

        Ok(())
    }

    /// Decodes a RISC0 receipt from proof data.
    ///
    /// Helper function to avoid duplicating deserialization logic.
    fn decode_receipt(proof: &ProofData) -> Result<Receipt, ProofError> {
        if proof.backend != ProofBackend::Risc0 {
            return Err(ProofError::ZkvmError(format!(
                "Expected Risc0 backend, got {:?}",
                proof.backend
            )));
        }

        bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))
    }

    /// Extracts the resulting GameState from a proof's journal.
    ///
    /// The journal contains public outputs in order:
    /// 1. GameState (after execution)
    /// 2. StateDelta
    /// 3. Action
    pub fn extract_result_state(proof: &ProofData) -> Result<GameState, ProofError> {
        let receipt = Self::decode_receipt(proof)?;

        receipt
            .journal
            .decode()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to decode GameState: {}", e)))
    }

    /// Extracts the Action from a proof's journal.
    ///
    /// Journal format: [GameState, Action]
    pub fn extract_action(proof: &ProofData) -> Result<Action, ProofError> {
        let receipt = Self::decode_receipt(proof)?;

        // Skip first value (GameState) and decode second value (Action)
        let mut decoder = receipt.journal.bytes.as_slice();
        let _state: GameState = bincode::deserialize_from(&mut decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        bincode::deserialize_from(decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))
    }
}
