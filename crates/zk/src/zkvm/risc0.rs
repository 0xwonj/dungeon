//! RISC0 zkVM prover implementation.
//!
//! Generates zero-knowledge proofs of game action execution using RISC0's zkVM.
//!
//! # Verification Flow
//!
//! 1. Host prepares inputs: oracle snapshot, before_state, action
//! 2. zkVM executes guest program with GameEngine
//! 3. Guest commits: after_state, action to journal (delta computation skipped)
//! 4. Host verifies journal matches expected state
//! 5. Returns proof if consistent, error otherwise
//!
//! # Performance
//!
//! - Production: ~30-60s per proof (with Metal acceleration)
//! - Dev mode (`RISC0_DEV_MODE=1`): <100ms (no real proving)

use risc0_zkvm::{ExecutorEnv, Receipt, default_prover};

use crate::prover::{ProofBackend, ProofData, ProofError};
use crate::{OracleSnapshot, Prover};
use game_core::{Action, GameState};

// Generated by build.rs - contains ELFs and ImageIDs
use crate::{
    BATCH_STATE_TRANSITION_ELF, BATCH_STATE_TRANSITION_ID, SINGLE_STATE_TRANSITION_ELF,
    SINGLE_STATE_TRANSITION_ID,
};

/// RISC0 zkVM prover.
///
/// Maintains a cached oracle snapshot that is reused across all proof generations.
#[derive(Clone)]
pub struct Risc0Prover {
    oracle_snapshot: OracleSnapshot,
}

impl Risc0Prover {
    /// Creates a new RISC0 prover with the given oracle snapshot.
    pub fn new(oracle_snapshot: OracleSnapshot) -> Self {
        Self { oracle_snapshot }
    }
}

impl Prover for Risc0Prover {
    fn prove(
        &self,
        before_state: &GameState,
        action: &Action,
        expected_after_state: &GameState,
    ) -> Result<ProofData, ProofError> {
        // Build executor environment (order must match guest's env::read() calls)
        let env = ExecutorEnv::builder()
            // 1. Oracle snapshot (static game content)
            .write(&self.oracle_snapshot)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write oracle_snapshot: {}", e)))?
            // 2. Game state before action execution
            .write(before_state)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write before_state: {}", e)))?
            // 3. Action to execute
            .write(action)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write action: {}", e)))?
            .build()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to build ExecutorEnv: {}", e)))?;

        // Generate proof using single state transition guest
        let prover = default_prover();
        let prove_info = prover
            .prove(env, SINGLE_STATE_TRANSITION_ELF)
            .map_err(|e| ProofError::ZkvmError(format!("Proof generation failed: {}", e)))?;

        let receipt = prove_info.receipt;

        // Verify zkVM-computed result matches expected state
        Self::verify_consistency(&receipt, expected_after_state)?;

        // Serialize receipt for storage/transmission
        let bytes = bincode::serialize(&receipt)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        Ok(ProofData {
            bytes,
            backend: ProofBackend::Risc0,
        })
    }

    fn prove_batch(
        &self,
        start_state: &GameState,
        actions: &[Action],
        expected_end_state: &GameState,
    ) -> Result<ProofData, ProofError> {
        // Build executor environment for batch proving
        // Order must match batch-state-transition guest's env::read() calls
        let env = ExecutorEnv::builder()
            // 1. Oracle snapshot (static game content)
            .write(&self.oracle_snapshot)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write oracle_snapshot: {}", e)))?
            // 2. Game state at batch start
            .write(start_state)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write start_state: {}", e)))?
            // 3. Batch of actions to execute
            .write(&actions.to_vec())
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write actions: {}", e)))?
            .build()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to build ExecutorEnv: {}", e)))?;

        // Generate proof using batch state transition guest
        let prover = default_prover();
        let prove_info = prover
            .prove(env, BATCH_STATE_TRANSITION_ELF)
            .map_err(|e| ProofError::ZkvmError(format!("Batch proof generation failed: {}", e)))?;

        let receipt = prove_info.receipt;

        // Verify zkVM-computed result matches expected end state
        Self::verify_batch_consistency(&receipt, expected_end_state, actions.len())?;

        // Serialize receipt for storage/transmission
        let bytes = bincode::serialize(&receipt)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        Ok(ProofData {
            bytes,
            backend: ProofBackend::Risc0,
        })
    }

    fn verify(&self, proof: &ProofData) -> Result<bool, ProofError> {
        // Verify backend matches
        if proof.backend != ProofBackend::Risc0 {
            return Err(ProofError::ZkvmError(format!(
                "Expected Risc0 backend, got {:?}",
                proof.backend
            )));
        }

        // Deserialize receipt
        let receipt: Receipt = bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        // Try verifying against both guest program ImageIDs
        // We don't know which guest generated this proof, so try both
        let single_result = receipt.verify(SINGLE_STATE_TRANSITION_ID);
        if single_result.is_ok() {
            return Ok(true);
        }

        let batch_result = receipt.verify(BATCH_STATE_TRANSITION_ID);
        if batch_result.is_ok() {
            return Ok(true);
        }

        // Both failed - return error
        Err(ProofError::ZkvmError(format!(
            "Proof verification failed against both guest programs. \
             Single transition error: {:?}, Batch transition error: {:?}",
            single_result.err(),
            batch_result.err()
        )))
    }
}

impl Risc0Prover {
    /// Verifies zkVM-computed result matches expected state (single action).
    ///
    /// This safety check catches non-determinism bugs, oracle mismatches, and
    /// zkVM-specific implementation issues. Verification happens on the host
    /// for efficiency since journal data is cryptographically committed.
    ///
    /// # Arguments
    ///
    /// * `receipt` - zkVM receipt containing journal with computed results
    /// * `expected_after_state` - State computed by simulation worker
    ///
    /// # Errors
    ///
    /// Returns `ProofError::StateInconsistency` if zkVM results don't match.
    fn verify_consistency(
        receipt: &Receipt,
        expected_after_state: &GameState,
    ) -> Result<(), ProofError> {
        // Extract after_state from zkVM journal
        // Journal order: [after_state, action]
        let zkvm_after_state: GameState = receipt.journal.decode().map_err(|e| {
            ProofError::SerializationError(format!("Failed to decode zkVM after_state: {}", e))
        })?;

        // Compare after_state
        if &zkvm_after_state != expected_after_state {
            return Err(ProofError::StateInconsistency(format!(
                "zkVM computed different after_state than simulation worker. \
                 This indicates non-determinism or oracle mismatch. \
                 zkVM clock={}, simulation clock={}",
                zkvm_after_state.turn.clock, expected_after_state.turn.clock
            )));
        }

        Ok(())
    }

    /// Verifies zkVM-computed batch result matches expected end state.
    ///
    /// Similar to verify_consistency but for batch proving.
    /// Journal format from batch-state-transition guest: [end_state, action_count]
    ///
    /// # Arguments
    ///
    /// * `receipt` - zkVM receipt containing journal with computed results
    /// * `expected_end_state` - Final state computed by simulation worker
    /// * `expected_action_count` - Number of actions that should have been executed
    ///
    /// # Errors
    ///
    /// Returns `ProofError::StateInconsistency` if zkVM results don't match.
    fn verify_batch_consistency(
        receipt: &Receipt,
        expected_end_state: &GameState,
        expected_action_count: usize,
    ) -> Result<(), ProofError> {
        // Extract end_state from zkVM journal
        // Journal order: [end_state, action_count]
        let zkvm_end_state: GameState = receipt.journal.decode().map_err(|e| {
            ProofError::SerializationError(format!("Failed to decode zkVM end_state: {}", e))
        })?;

        // Extract action_count from journal
        let zkvm_action_count: u64 = receipt.journal.decode().map_err(|e| {
            ProofError::SerializationError(format!("Failed to decode action_count: {}", e))
        })?;

        // Verify action count matches
        if zkvm_action_count != expected_action_count as u64 {
            return Err(ProofError::StateInconsistency(format!(
                "zkVM executed different number of actions. \
                 Expected {}, got {}",
                expected_action_count, zkvm_action_count
            )));
        }

        // Compare end_state
        if &zkvm_end_state != expected_end_state {
            return Err(ProofError::StateInconsistency(format!(
                "zkVM computed different end_state than simulation worker. \
                 This indicates non-determinism or oracle mismatch. \
                 zkVM clock={}, simulation clock={}",
                zkvm_end_state.turn.clock, expected_end_state.turn.clock
            )));
        }

        Ok(())
    }

    /// Decodes a RISC0 receipt from proof data.
    ///
    /// Helper function to avoid duplicating deserialization logic.
    fn decode_receipt(proof: &ProofData) -> Result<Receipt, ProofError> {
        if proof.backend != ProofBackend::Risc0 {
            return Err(ProofError::ZkvmError(format!(
                "Expected Risc0 backend, got {:?}",
                proof.backend
            )));
        }

        bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))
    }

    /// Extracts the resulting GameState from a proof's journal.
    ///
    /// The journal contains public outputs in order:
    /// 1. GameState (after execution)
    /// 2. StateDelta
    /// 3. Action
    pub fn extract_result_state(proof: &ProofData) -> Result<GameState, ProofError> {
        let receipt = Self::decode_receipt(proof)?;

        receipt
            .journal
            .decode()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to decode GameState: {}", e)))
    }

    /// Extracts the Action from a proof's journal.
    ///
    /// Journal format: [GameState, Action]
    pub fn extract_action(proof: &ProofData) -> Result<Action, ProofError> {
        let receipt = Self::decode_receipt(proof)?;

        // Skip first value (GameState) and decode second value (Action)
        let mut decoder = receipt.journal.bytes.as_slice();
        let _state: GameState = bincode::deserialize_from(&mut decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        bincode::deserialize_from(decoder)
            .map_err(|e| ProofError::SerializationError(e.to_string()))
    }
}
