//! SP1 zkVM prover implementation.
//!
//! Generates zero-knowledge proofs of game action execution using SP1's zkVM.
//!
//! # Two-Stage Verification Model
//!
//! SP1 Groth16 proofs use a two-stage verification approach:
//!
//! **Stage 1 (On-chain):** Groth16 proof verification
//! - Verifies the cryptographic proof
//! - Public input: public_values_digest (SHA-256 of public values)
//! - This proves: "Some valid execution produced this public values digest"
//!
//! **Stage 2 (On-chain):** Public values content verification
//! - Contract receives 168-byte public values data
//! - Verifies: SHA-256(public_values) == public_values_digest
//! - Extracts and validates 6 fields from public values
//! - This proves: "The public values contain these specific committed values"
//!
//! # Public Values Structure (168 bytes)
//!
//! ```text
//! 1. oracle_root       (32 bytes, offset 0..32)   - Static game content commitment
//! 2. seed_commitment   (32 bytes, offset 32..64)  - RNG seed commitment
//! 3. prev_state_root   (32 bytes, offset 64..96)  - State before execution
//! 4. actions_root      (32 bytes, offset 96..128) - Action sequence commitment
//! 5. new_state_root    (32 bytes, offset 128..160) - State after execution
//! 6. new_nonce         (8 bytes, offset 160..168) - Action counter
//! ```
//!
//! # Guest Program Flow
//!
//! The zkVM guest program commits these 6 fields to public values in exact order.
//!
//! # Host Verification
//!
//! After proof generation, the host verifies public values consistency:
//! - oracle_root matches OracleSnapshot hash
//! - prev_state_root matches start_state hash
//! - new_state_root matches expected_end_state hash
//! - new_nonce matches expected_end_state.nonce()
//!
//! This catches non-determinism bugs and oracle mismatches before on-chain submission.

use sha2::{Digest, Sha256};
use sp1_sdk::{EnvProver, SP1ProofWithPublicValues, SP1ProvingKey, SP1Stdin, SP1VerifyingKey};

use crate::prover::{ProofBackend, ProofData, ProofError, Prover};
use crate::{OracleSnapshot, compute_journal_digest, parse_journal};
use game_core::{Action, GameState};

// Generated by build.rs - contains ELF
use crate::STATE_TRANSITION_ELF;

/// SP1 zkVM prover.
///
/// SP1's EnvProver should be initialized once and reused for performance.
/// According to SP1 best practices, initialization is expensive as it loads
/// proving parameters and sets up the environment.
///
/// # Prover Configuration
///
/// The prover is configured via environment variables:
///
/// ## Prover Mode (`SP1_PROVER`)
/// - `cpu` (default): Local CPU proving (slow, high memory usage)
/// - `network`: Succinct Prover Network (fast, requires API key)
/// - `cuda`: Local CUDA GPU proving (fastest, requires NVIDIA GPU)
/// - `mock`: Mock proving for testing (instant, no real proofs)
///
/// ## Proof Mode (`SP1_PROOF_MODE`)
/// - `compressed` (default): Compressed STARK (~4-5MB, off-chain verification)
/// - `groth16`: Groth16 SNARK (~260 bytes, on-chain verification, Sui compatible)
/// - `plonk`: PLONK SNARK (~868 bytes, on-chain, no trusted setup)
///
/// ## Network Mode Configuration
///
/// To use the Succinct Prover Network:
/// ```bash
/// export SP1_PROVER=network
/// export SP1_PROOF_MODE=groth16
/// export NETWORK_PRIVATE_KEY=0x...  # Your network prover private key
/// ```
///
/// Optional network settings:
/// ```bash
/// export NETWORK_RPC_URL=https://rpc.succinct.xyz  # Custom RPC endpoint
/// ```
///
/// Benefits of network mode:
/// - ✅ No local resource requirements (no Docker, no high memory)
/// - ✅ Fast proof generation (~minutes vs hours)
/// - ✅ All proof modes supported (compressed, groth16, plonk)
/// - ⚠️ Requires network prover account and API key
///
/// This struct maintains:
/// - EnvProver (reused across all operations)
/// - Oracle snapshot (static game content)
/// - Proving/Verifying keys (cached for the state-transition program)
pub struct Sp1Prover {
    oracle_snapshot: OracleSnapshot,
    client: EnvProver,
    pk: SP1ProvingKey,
    vk: SP1VerifyingKey,
}

impl Sp1Prover {
    /// Creates a new SP1 prover with the given oracle snapshot.
    ///
    /// Initializes EnvProver from environment variables:
    /// - `SP1_PROVER`: Selects prover mode (cpu, network, cuda, mock)
    /// - `SP1_PROOF_MODE`: Selects proof type (compressed, groth16, plonk)
    /// - `NETWORK_PRIVATE_KEY`: Required for network mode
    /// - `NETWORK_RPC_URL`: Optional custom RPC endpoint for network mode
    ///
    /// # Performance Note
    /// EnvProver initialization is expensive - this should be called once
    /// and the Sp1Prover instance reused for all subsequent proving operations.
    ///
    /// # Examples
    ///
    /// Local Groth16 (requires Docker with 12-16GB RAM):
    /// ```bash
    /// export SP1_PROVER=cpu
    /// export SP1_PROOF_MODE=groth16
    /// cargo run -p client-cli --no-default-features --features sp1
    /// ```
    ///
    /// Network Groth16 (fast, no local resources):
    /// ```bash
    /// export SP1_PROVER=network
    /// export SP1_PROOF_MODE=groth16
    /// export NETWORK_PRIVATE_KEY=0x1234...
    /// cargo run -p client-cli --no-default-features --features sp1
    /// ```
    pub fn new(oracle_snapshot: OracleSnapshot) -> Self {
        let client = sp1_sdk::ProverClient::from_env();
        let (pk, vk) = client.setup(STATE_TRANSITION_ELF);

        Self {
            oracle_snapshot,
            client,
            pk,
            vk,
        }
    }

    /// Returns reference to the cached EnvProver.
    ///
    /// Exposed for groth16 module to reuse the client.
    pub fn client(&self) -> &EnvProver {
        &self.client
    }

    /// Returns reference to the proving key.
    pub fn pk(&self) -> &SP1ProvingKey {
        &self.pk
    }

    /// Returns reference to the verifying key.
    pub fn vk(&self) -> &SP1VerifyingKey {
        &self.vk
    }

    /// Returns reference to the oracle snapshot.
    pub fn oracle_snapshot(&self) -> &OracleSnapshot {
        &self.oracle_snapshot
    }

    /// Computes seed commitment from GameState's game_seed.
    ///
    /// The seed commitment is SHA-256(game_seed), providing a cryptographic
    /// commitment to the RNG seed without revealing it.
    pub fn compute_seed_commitment(state: &GameState) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(state.game_seed.to_le_bytes());
        hasher.finalize().into()
    }

    /// Verifies public values fields match expected values (exposed for groth16).
    ///
    /// Checks that zkVM-committed values match host-computed values:
    /// - oracle_root: Must match oracle snapshot hash
    /// - seed_commitment: Must match game seed commitment
    /// - prev_state_root: Must match start_state hash
    /// - actions_root: Must match hash of action sequence
    /// - new_state_root: Must match expected_end_state hash
    /// - new_nonce: Must match expected_end_state.nonce()
    ///
    /// # Errors
    ///
    /// Returns `ProofError::StateInconsistency` if any field mismatches.
    pub fn verify_journal_fields(
        &self,
        journal_bytes: &[u8],
        start_state: &GameState,
        actions: &[Action],
        expected_end_state: &GameState,
    ) -> Result<(), ProofError> {
        // Parse 168-byte public values into 6 fields
        let fields = parse_journal(journal_bytes)?;

        // Compute expected values
        let expected_oracle_root = self.oracle_snapshot.compute_oracle_root();
        let expected_seed_commitment = Self::compute_seed_commitment(start_state);
        let expected_prev_state_root = start_state.compute_state_root();
        let expected_actions_root = game_core::compute_actions_root(actions);
        let expected_new_state_root = expected_end_state.compute_state_root();
        let expected_new_nonce = expected_end_state.nonce();

        // Verify oracle_root
        if fields.oracle_root != expected_oracle_root {
            return Err(ProofError::StateInconsistency(format!(
                "oracle_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.oracle_root, expected_oracle_root
            )));
        }

        // Verify seed_commitment
        if fields.seed_commitment != expected_seed_commitment {
            return Err(ProofError::StateInconsistency(format!(
                "seed_commitment mismatch: zkVM committed {:?}, expected {:?}",
                fields.seed_commitment, expected_seed_commitment
            )));
        }

        // Verify prev_state_root
        if fields.prev_state_root != expected_prev_state_root {
            return Err(ProofError::StateInconsistency(format!(
                "prev_state_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.prev_state_root, expected_prev_state_root
            )));
        }

        // Verify actions_root
        if fields.actions_root != expected_actions_root {
            return Err(ProofError::StateInconsistency(format!(
                "actions_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.actions_root, expected_actions_root
            )));
        }

        // Verify new_state_root
        if fields.new_state_root != expected_new_state_root {
            // STATE MISMATCH DETECTED - Perform detailed debugging
            tracing::error!("State root mismatch detected! Performing detailed analysis...");

            // Re-execute actions on host to simulate zkVM execution
            let mut debug_state = start_state.clone();
            let snapshot_bundle = game_core::SnapshotOracleBundle::new(&self.oracle_snapshot);
            let env = snapshot_bundle.as_env();
            let mut engine = game_core::GameEngine::new(&mut debug_state);

            for (idx, action) in actions.iter().enumerate() {
                match engine.execute(env.as_game_env(), action) {
                    Ok(_) => {}
                    Err(e) => {
                        tracing::error!(
                            "Re-execution failed at action {}/{}: {:?}",
                            idx + 1,
                            actions.len(),
                            e
                        );
                        break;
                    }
                }
            }

            let recomputed_root = debug_state.compute_state_root();

            tracing::error!("=== STATE ROOT MISMATCH ANALYSIS ===");
            tracing::error!("zkVM computed:     {:?}", fields.new_state_root);
            tracing::error!("Expected (file):   {:?}", expected_new_state_root);
            tracing::error!("Re-executed (host):{:?}", recomputed_root);
            tracing::error!("zkVM nonce:        {}", fields.new_nonce);
            tracing::error!("Expected nonce:    {}", expected_new_nonce);
            tracing::error!("Re-executed nonce: {}", debug_state.nonce());

            // Compare field by field
            tracing::error!("=== FIELD-BY-FIELD COMPARISON ===");
            tracing::error!(
                "game_seed: expected={}, re-executed={}",
                expected_end_state.game_seed,
                debug_state.game_seed
            );

            // Turn state
            tracing::error!(
                "turn.nonce: expected={}, re-executed={}",
                expected_end_state.turn.nonce,
                debug_state.turn.nonce
            );
            tracing::error!(
                "turn.clock: expected={}, re-executed={}",
                expected_end_state.turn.clock,
                debug_state.turn.clock
            );
            tracing::error!(
                "turn.current_actor: expected={:?}, re-executed={:?}",
                expected_end_state.turn.current_actor,
                debug_state.turn.current_actor
            );
            tracing::error!(
                "turn.active_actors: expected={:?}, re-executed={:?}",
                expected_end_state.turn.active_actors,
                debug_state.turn.active_actors
            );

            // Entities
            tracing::error!(
                "entities.actors.len(): expected={}, re-executed={}",
                expected_end_state.entities.actors.len(),
                debug_state.entities.actors.len()
            );
            tracing::error!(
                "entities.items.len(): expected={}, re-executed={}",
                expected_end_state.entities.items.len(),
                debug_state.entities.items.len()
            );
            tracing::error!(
                "entities.props.len(): expected={}, re-executed={}",
                expected_end_state.entities.props.len(),
                debug_state.entities.props.len()
            );

            // World
            tracing::error!(
                "world.tile_map.occupancy().len(): expected={}, re-executed={}",
                expected_end_state.world.tile_map.occupancy().len(),
                debug_state.world.tile_map.occupancy().len()
            );

            // Check if re-executed matches zkVM (most important!)
            if recomputed_root == fields.new_state_root {
                tracing::error!(
                    "✓ Re-execution matches zkVM! Problem is with expected_end_state from file."
                );
                tracing::error!("This suggests bincode deserialization or file persistence issue.");
            } else if recomputed_root == expected_new_state_root {
                tracing::error!("✓ Re-execution matches expected! zkVM produced different result.");
                tracing::error!("This suggests non-determinism in zkVM execution.");
            } else {
                tracing::error!("✗ Re-execution matches neither! All three states are different.");
                tracing::error!("This suggests fundamental execution non-determinism.");
            }

            return Err(ProofError::StateInconsistency(format!(
                "new_state_root mismatch: zkVM computed {:?}, expected {:?}. \
                 This indicates non-determinism. zkVM nonce={}, expected nonce={}. \
                 See logs above for detailed field comparison.",
                fields.new_state_root,
                expected_new_state_root,
                fields.new_nonce,
                expected_new_nonce
            )));
        }

        // Verify new_nonce
        if fields.new_nonce != expected_new_nonce {
            return Err(ProofError::StateInconsistency(format!(
                "new_nonce mismatch: zkVM computed {}, expected {}",
                fields.new_nonce, expected_new_nonce
            )));
        }

        Ok(())
    }
}

impl Prover for Sp1Prover {
    fn prove(
        &self,
        start_state: &GameState,
        actions: &[Action],
        expected_end_state: &GameState,
    ) -> Result<ProofData, ProofError> {
        // Compute seed commitment from game state
        let seed_commitment = Self::compute_seed_commitment(start_state);

        // Build stdin (SP1's equivalent of ExecutorEnv)
        // Order must match state-transition guest's sp1_zkvm::io::read() calls
        let mut stdin = SP1Stdin::new();

        // 1. Oracle snapshot (static game content)
        stdin.write(&self.oracle_snapshot);

        // 2. Seed commitment (RNG seed commitment)
        stdin.write(&seed_commitment);

        // 3. Game state at start
        stdin.write(start_state);

        // 4. Actions to execute
        stdin.write(&actions.to_vec());

        // Generate proof using state transition guest
        // SP1 5.2 uses builder pattern to select proof type at runtime
        //
        // Proof type is determined by SP1_PROOF_MODE environment variable:
        // - compressed (default): Compressed STARK (~4-5MB, off-chain)
        // - groth16: Groth16 SNARK (~260 bytes, on-chain, Sui compatible)
        // - plonk: PLONK SNARK (~868 bytes, on-chain, no trusted setup)
        let proof_mode =
            std::env::var("SP1_PROOF_MODE").unwrap_or_else(|_| "compressed".to_string());

        let proof = match proof_mode.to_lowercase().as_str() {
            "groth16" => {
                tracing::info!("Generating Groth16 proof (SP1_PROOF_MODE=groth16)");
                self.client
                    .prove(&self.pk, &stdin)
                    .groth16()
                    .run()
                    .map_err(|e| {
                        ProofError::ZkvmError(format!(
                            "SP1 Groth16 proof generation failed: {}. \
                             Platform-independent, works on all systems.",
                            e
                        ))
                    })?
            }
            "plonk" => {
                tracing::info!("Generating PLONK proof (SP1_PROOF_MODE=plonk)");
                self.client
                    .prove(&self.pk, &stdin)
                    .plonk()
                    .run()
                    .map_err(|e| {
                        ProofError::ZkvmError(format!("SP1 PLONK proof generation failed: {}", e))
                    })?
            }
            "compressed" | _ => {
                if proof_mode != "compressed" {
                    tracing::warn!(
                        "Invalid SP1_PROOF_MODE '{}', defaulting to 'compressed'. \
                         Valid options: compressed, groth16, plonk",
                        proof_mode
                    );
                }
                tracing::info!("Generating Compressed proof (SP1_PROOF_MODE=compressed)");
                self.client
                    .prove(&self.pk, &stdin)
                    .compressed()
                    .run()
                    .map_err(|e| {
                        ProofError::ZkvmError(format!(
                            "SP1 Compressed proof generation failed: {}",
                            e
                        ))
                    })?
            }
        };

        // Extract 168-byte public values from proof
        let journal = proof.public_values.to_vec();

        // Verify public values fields match expected values
        self.verify_journal_fields(&journal, start_state, actions, expected_end_state)?;

        // Compute public values digest (SHA-256 of public values)
        let journal_digest = compute_journal_digest(&journal);

        // Serialize proof for storage/transmission
        let bytes = bincode::serialize(&proof)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        Ok(ProofData {
            bytes,
            backend: ProofBackend::Sp1,
            journal,
            journal_digest,
        })
    }

    fn verify(&self, proof: &ProofData) -> Result<bool, ProofError> {
        // Verify backend matches
        if proof.backend != ProofBackend::Sp1 {
            return Err(ProofError::ZkvmError(format!(
                "Expected SP1 backend, got {:?}",
                proof.backend
            )));
        }

        // Deserialize proof
        let sp1_proof: SP1ProofWithPublicValues = bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        // Verify proof against state transition guest program
        // Reuse the cached ProverClient from initialization for performance
        self.client.verify(&sp1_proof, &self.vk).map_err(|e| {
            ProofError::ZkvmError(format!("SP1 proof verification failed: {:?}", e))
        })?;

        Ok(true)
    }
}
