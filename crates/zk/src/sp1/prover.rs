//! SP1 zkVM prover implementation.
//!
//! Generates zero-knowledge proofs of game action execution using SP1's zkVM.

use sha2::{Digest, Sha256};
use sp1_sdk::{EnvProver, SP1ProofWithPublicValues, SP1ProvingKey, SP1Stdin, SP1VerifyingKey};

use crate::prover::{ProofBackend, ProofData, ProofError, Prover};
use crate::{OracleSnapshot, compute_journal_digest, parse_journal};
use game_core::{Action, GameState};

// Generated by build.rs - contains ELF
use crate::STATE_TRANSITION_ELF;

/// SP1 zkVM prover.
///
/// # Prover Configuration
///
/// The prover is configured via environment variables:
///
/// ## Prover Mode (`SP1_PROVER`)
/// - `cpu` (default): Local CPU proving (slow, high memory usage)
/// - `network`: Succinct Prover Network (fast, requires API key)
/// - `cuda`: Local CUDA GPU proving (fastest, requires NVIDIA GPU)
/// - `mock`: Mock proving for testing (instant, no real proofs)
///
/// ## Proof Mode (`SP1_PROOF_MODE`)
/// - `compressed` (default): Compressed STARK (~4-5MB, off-chain verification)
/// - `groth16`: Groth16 SNARK (~260 bytes, on-chain verification, Sui compatible)
/// - `plonk`: PLONK SNARK (~868 bytes, on-chain, no trusted setup)
pub struct Sp1Prover {
    oracle_snapshot: OracleSnapshot,
    client: EnvProver,
    pk: SP1ProvingKey,
    vk: SP1VerifyingKey,
}

impl Sp1Prover {
    /// Creates a new SP1 prover with the given oracle snapshot.
    ///
    /// Initializes EnvProver from environment variables:
    /// - `SP1_PROVER`: Selects prover mode (cpu, network, cuda, mock)
    /// - `SP1_PROOF_MODE`: Selects proof type (compressed, groth16, plonk)
    /// - `NETWORK_PRIVATE_KEY`: Required for network mode
    /// - `NETWORK_RPC_URL`: Optional custom RPC endpoint for network mode
    pub fn new(oracle_snapshot: OracleSnapshot) -> Self {
        let client = sp1_sdk::ProverClient::from_env();
        let (pk, vk) = client.setup(STATE_TRANSITION_ELF);

        Self {
            oracle_snapshot,
            client,
            pk,
            vk,
        }
    }

    /// Returns reference to the cached EnvProver.
    ///
    /// Exposed for groth16 module to reuse the client.
    pub fn client(&self) -> &EnvProver {
        &self.client
    }

    /// Returns reference to the proving key.
    pub fn pk(&self) -> &SP1ProvingKey {
        &self.pk
    }

    /// Returns reference to the verifying key.
    pub fn vk(&self) -> &SP1VerifyingKey {
        &self.vk
    }

    /// Returns reference to the oracle snapshot.
    pub fn oracle_snapshot(&self) -> &OracleSnapshot {
        &self.oracle_snapshot
    }

    /// Computes seed commitment from GameState's game_seed.
    ///
    /// The seed commitment is SHA-256(game_seed), providing a cryptographic
    /// commitment to the RNG seed without revealing it.
    pub fn compute_seed_commitment(state: &GameState) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(state.game_seed.to_le_bytes());
        hasher.finalize().into()
    }

    /// Verifies public values fields match expected values (exposed for groth16).
    ///
    /// # Errors
    ///
    /// Returns `ProofError::StateInconsistency` if any field mismatches.
    pub fn verify_journal_fields(
        &self,
        journal_bytes: &[u8],
        start_state: &GameState,
        actions: &[Action],
        expected_end_state: &GameState,
    ) -> Result<(), ProofError> {
        // Parse 168-byte public values into 6 fields
        let fields = parse_journal(journal_bytes)?;

        // Compute expected values
        let expected_oracle_root = self.oracle_snapshot.compute_oracle_root();
        let expected_seed_commitment = Self::compute_seed_commitment(start_state);
        let expected_prev_state_root = start_state.compute_state_root();
        let expected_actions_root = game_core::compute_actions_root(actions);
        let expected_new_state_root = expected_end_state.compute_state_root();
        let expected_new_nonce = expected_end_state.nonce();

        // Verify oracle_root
        if fields.oracle_root != expected_oracle_root {
            return Err(ProofError::StateInconsistency(format!(
                "oracle_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.oracle_root, expected_oracle_root
            )));
        }

        // Verify seed_commitment
        if fields.seed_commitment != expected_seed_commitment {
            return Err(ProofError::StateInconsistency(format!(
                "seed_commitment mismatch: zkVM committed {:?}, expected {:?}",
                fields.seed_commitment, expected_seed_commitment
            )));
        }

        // Verify prev_state_root
        if fields.prev_state_root != expected_prev_state_root {
            return Err(ProofError::StateInconsistency(format!(
                "prev_state_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.prev_state_root, expected_prev_state_root
            )));
        }

        // Verify actions_root
        if fields.actions_root != expected_actions_root {
            return Err(ProofError::StateInconsistency(format!(
                "actions_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.actions_root, expected_actions_root
            )));
        }

        // Verify new_state_root
        if fields.new_state_root != expected_new_state_root {
            return Err(ProofError::StateInconsistency(format!(
                "new_state_root mismatch: zkVM computed {:?}, expected {:?}. \
                 This indicates non-determinism. zkVM nonce={}, expected nonce={}.",
                fields.new_state_root,
                expected_new_state_root,
                fields.new_nonce,
                expected_new_nonce
            )));
        }

        // Verify new_nonce
        if fields.new_nonce != expected_new_nonce {
            return Err(ProofError::StateInconsistency(format!(
                "new_nonce mismatch: zkVM computed {}, expected {}",
                fields.new_nonce, expected_new_nonce
            )));
        }

        Ok(())
    }
}

impl Prover for Sp1Prover {
    fn prove(
        &self,
        start_state: &GameState,
        actions: &[Action],
        expected_end_state: &GameState,
    ) -> Result<ProofData, ProofError> {
        // Compute seed commitment from game state
        let seed_commitment = Self::compute_seed_commitment(start_state);

        // Build stdin (SP1's equivalent of ExecutorEnv)
        // Order must match state-transition guest's sp1_zkvm::io::read() calls
        let mut stdin = SP1Stdin::new();

        // 1. Oracle snapshot (static game content)
        stdin.write(&self.oracle_snapshot);

        // 2. Seed commitment (RNG seed commitment)
        stdin.write(&seed_commitment);

        // 3. Game state at start
        stdin.write(start_state);

        // 4. Actions to execute
        stdin.write(&actions.to_vec());

        // Generate proof using state transition guest
        let proof_mode =
            std::env::var("SP1_PROOF_MODE").unwrap_or_else(|_| "compressed".to_string());

        let proof = match proof_mode.to_lowercase().as_str() {
            "groth16" => {
                tracing::info!("Generating Groth16 proof (SP1_PROOF_MODE=groth16)");
                self.client
                    .prove(&self.pk, &stdin)
                    .groth16()
                    .run()
                    .map_err(|e| {
                        ProofError::ZkvmError(format!(
                            "SP1 Groth16 proof generation failed: {}. \
                             Platform-independent, works on all systems.",
                            e
                        ))
                    })?
            }
            "plonk" => {
                tracing::info!("Generating PLONK proof (SP1_PROOF_MODE=plonk)");
                self.client
                    .prove(&self.pk, &stdin)
                    .plonk()
                    .run()
                    .map_err(|e| {
                        ProofError::ZkvmError(format!("SP1 PLONK proof generation failed: {}", e))
                    })?
            }
            "compressed" => {
                tracing::info!("Generating Compressed proof (SP1_PROOF_MODE=compressed)");
                self.client
                    .prove(&self.pk, &stdin)
                    .compressed()
                    .run()
                    .map_err(|e| {
                        ProofError::ZkvmError(format!(
                            "SP1 Compressed proof generation failed: {}",
                            e
                        ))
                    })?
            }
            _ => {
                tracing::warn!(
                    "Invalid SP1_PROOF_MODE '{}', defaulting to 'compressed'. \
                     Valid options: compressed, groth16, plonk",
                    proof_mode
                );
                tracing::info!("Generating Compressed proof (SP1_PROOF_MODE=compressed)");
                self.client
                    .prove(&self.pk, &stdin)
                    .compressed()
                    .run()
                    .map_err(|e| {
                        ProofError::ZkvmError(format!(
                            "SP1 Compressed proof generation failed: {}",
                            e
                        ))
                    })?
            }
        };

        // Extract 168-byte public values from proof
        let journal = proof.public_values.to_vec();

        // Verify public values fields match expected values
        self.verify_journal_fields(&journal, start_state, actions, expected_end_state)?;

        // Compute public values digest (SHA-256 of public values)
        let journal_digest = compute_journal_digest(&journal);

        // Serialize proof for storage/transmission
        let bytes = bincode::serialize(&proof)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        Ok(ProofData {
            bytes,
            backend: ProofBackend::Sp1,
            journal,
            journal_digest,
        })
    }

    fn verify(&self, proof: &ProofData) -> Result<bool, ProofError> {
        // Verify backend matches
        if proof.backend != ProofBackend::Sp1 {
            return Err(ProofError::ZkvmError(format!(
                "Expected SP1 backend, got {:?}",
                proof.backend
            )));
        }

        // Deserialize proof
        let sp1_proof: SP1ProofWithPublicValues = bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        // Verify proof against state transition guest program
        // Reuse the cached ProverClient from initialization for performance
        self.client.verify(&sp1_proof, &self.vk).map_err(|e| {
            ProofError::ZkvmError(format!("SP1 proof verification failed: {:?}", e))
        })?;

        Ok(true)
    }
}
