//! RISC0 zkVM prover implementation.
//!
//! Generates zero-knowledge proofs of game action execution using RISC0's zkVM.
//!
//! # Two-Stage Verification Model
//!
//! RISC0 Groth16 proofs use a two-stage verification approach:
//!
//! **Stage 1 (On-chain):** Groth16 proof verification
//! - Verifies the cryptographic proof (seal)
//! - Public input: journal_digest (SHA-256 of journal)
//! - This proves: "Some valid execution produced this journal digest"
//!
//! **Stage 2 (On-chain):** Journal content verification
//! - Contract receives 168-byte journal data
//! - Verifies: SHA-256(journal) == journal_digest
//! - Extracts and validates 6 fields from journal
//! - This proves: "The journal contains these specific committed values"
//!
//! # Journal Structure (168 bytes)
//!
//! ```text
//! 1. oracle_root       (32 bytes, offset 0..32)   - Static game content commitment
//! 2. seed_commitment   (32 bytes, offset 32..64)  - RNG seed commitment
//! 3. prev_state_root   (32 bytes, offset 64..96)  - State before execution
//! 4. actions_root      (32 bytes, offset 96..128) - Action sequence commitment
//! 5. new_state_root    (32 bytes, offset 128..160) - State after execution
//! 6. new_nonce         (8 bytes, offset 160..168) - Action counter
//! ```
//!
//! # Guest Program Flow
//!
//! The zkVM guest programs commit these 6 fields to the journal in exact order:
//! - `single-state-transition`: Proves single action execution (actions_root = zeros)
//! - `batch-state-transition`: Proves batch action execution (actions_root = hash of actions)
//!
//! # Host Verification
//!
//! After proof generation, the host verifies journal consistency:
//! - oracle_root matches OracleSnapshot hash
//! - prev_state_root matches before_state hash
//! - new_state_root matches expected_after_state hash
//! - new_nonce matches expected_after_state.nonce()
//!
//! This catches non-determinism bugs and oracle mismatches before on-chain submission.

use risc0_zkvm::{ExecutorEnv, Receipt, default_prover};
use sha2::{Digest, Sha256};

use crate::prover::{ProofBackend, ProofData, ProofError};
use crate::{OracleSnapshot, Prover, compute_journal_digest, parse_journal};
use game_core::{Action, GameState};

// Generated by build.rs - contains ELFs and ImageIDs
use crate::{STATE_TRANSITION_ELF, STATE_TRANSITION_ID};

/// RISC0 zkVM prover.
///
/// Maintains a cached oracle snapshot that is reused across all proof generations.
#[derive(Clone)]
pub struct Risc0Prover {
    oracle_snapshot: OracleSnapshot,
}

impl Risc0Prover {
    /// Creates a new RISC0 prover with the given oracle snapshot.
    pub fn new(oracle_snapshot: OracleSnapshot) -> Self {
        Self { oracle_snapshot }
    }

    /// Computes seed commitment from GameState's game_seed.
    ///
    /// The seed commitment is SHA-256(game_seed), providing a cryptographic
    /// commitment to the RNG seed without revealing it.
    fn compute_seed_commitment(state: &GameState) -> [u8; 32] {
        let mut hasher = Sha256::new();
        hasher.update(state.game_seed.to_le_bytes());
        hasher.finalize().into()
    }

    /// Verifies journal fields match expected values.
    ///
    /// Checks that zkVM-committed values match host-computed values:
    /// - oracle_root: Must match oracle snapshot hash
    /// - seed_commitment: Must match game seed commitment
    /// - prev_state_root: Must match start_state hash
    /// - actions_root: Must match hash of action sequence
    /// - new_state_root: Must match expected_end_state hash
    /// - new_nonce: Must match expected_end_state.nonce()
    ///
    /// # Errors
    ///
    /// Returns `ProofError::StateInconsistency` if any field mismatches.
    fn verify_journal_fields(
        &self,
        journal_bytes: &[u8],
        start_state: &GameState,
        actions: &[Action],
        expected_end_state: &GameState,
    ) -> Result<(), ProofError> {
        // Parse 168-byte journal into 6 fields
        let fields = parse_journal(journal_bytes)?;

        // Compute expected values
        let expected_oracle_root = self.oracle_snapshot.compute_oracle_root();
        let expected_seed_commitment = Self::compute_seed_commitment(start_state);
        let expected_prev_state_root = start_state.compute_state_root();
        let expected_actions_root = game_core::compute_actions_root(actions);
        let expected_new_state_root = expected_end_state.compute_state_root();
        let expected_new_nonce = expected_end_state.nonce();

        // Verify oracle_root
        if fields.oracle_root != expected_oracle_root {
            return Err(ProofError::StateInconsistency(format!(
                "oracle_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.oracle_root, expected_oracle_root
            )));
        }

        // Verify seed_commitment
        if fields.seed_commitment != expected_seed_commitment {
            return Err(ProofError::StateInconsistency(format!(
                "seed_commitment mismatch: zkVM committed {:?}, expected {:?}",
                fields.seed_commitment, expected_seed_commitment
            )));
        }

        // Verify prev_state_root
        if fields.prev_state_root != expected_prev_state_root {
            return Err(ProofError::StateInconsistency(format!(
                "prev_state_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.prev_state_root, expected_prev_state_root
            )));
        }

        // Verify actions_root
        if fields.actions_root != expected_actions_root {
            return Err(ProofError::StateInconsistency(format!(
                "actions_root mismatch: zkVM computed {:?}, expected {:?}",
                fields.actions_root, expected_actions_root
            )));
        }

        // Verify new_state_root
        if fields.new_state_root != expected_new_state_root {
            return Err(ProofError::StateInconsistency(format!(
                "new_state_root mismatch: zkVM computed {:?}, expected {:?}. \
                 This indicates non-determinism. zkVM nonce={}, expected nonce={}.",
                fields.new_state_root,
                expected_new_state_root,
                fields.new_nonce,
                expected_new_nonce
            )));
        }

        // Verify new_nonce
        if fields.new_nonce != expected_new_nonce {
            return Err(ProofError::StateInconsistency(format!(
                "new_nonce mismatch: zkVM computed {}, expected {}",
                fields.new_nonce, expected_new_nonce
            )));
        }

        Ok(())
    }
}

impl Prover for Risc0Prover {
    fn prove(
        &self,
        start_state: &GameState,
        actions: &[Action],
        expected_end_state: &GameState,
    ) -> Result<ProofData, ProofError> {
        // Compute seed commitment from game state
        let seed_commitment = Self::compute_seed_commitment(start_state);

        // Build executor environment
        // Order must match state-transition guest's env::read() calls
        let env = ExecutorEnv::builder()
            // 1. Oracle snapshot (static game content)
            .write(&self.oracle_snapshot)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write oracle_snapshot: {}", e)))?
            // 2. Seed commitment (RNG seed commitment)
            .write(&seed_commitment)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write seed_commitment: {}", e)))?
            // 3. Game state at start
            .write(start_state)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write start_state: {}", e)))?
            // 4. Actions to execute
            .write(&actions.to_vec())
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write actions: {}", e)))?
            .build()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to build ExecutorEnv: {}", e)))?;

        // Generate proof using state transition guest
        let prover = default_prover();
        let prove_info = prover
            .prove(env, STATE_TRANSITION_ELF)
            .map_err(|e| ProofError::ZkvmError(format!("Proof generation failed: {}", e)))?;

        let receipt = prove_info.receipt;

        // Extract 168-byte journal from receipt
        let journal = receipt.journal.bytes.clone();

        // Verify journal fields match expected values
        self.verify_journal_fields(&journal, start_state, actions, expected_end_state)?;

        // Compute journal digest (SHA-256 of journal)
        let journal_digest = compute_journal_digest(&journal);

        // Serialize receipt for storage/transmission
        let bytes = bincode::serialize(&receipt)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        Ok(ProofData {
            bytes,
            backend: ProofBackend::Risc0,
            journal,
            journal_digest,
        })
    }

    fn verify(&self, proof: &ProofData) -> Result<bool, ProofError> {
        // Verify backend matches
        if proof.backend != ProofBackend::Risc0 {
            return Err(ProofError::ZkvmError(format!(
                "Expected Risc0 backend, got {:?}",
                proof.backend
            )));
        }

        // Deserialize receipt
        let receipt: Receipt = bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        // Verify against state transition guest program ImageID
        receipt
            .verify(STATE_TRANSITION_ID)
            .map_err(|e| ProofError::ZkvmError(format!("Proof verification failed: {:?}", e)))?;

        Ok(true)
    }
}
