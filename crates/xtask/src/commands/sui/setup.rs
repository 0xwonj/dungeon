//! Sui deployment setup command (VK registration, etc.).

use std::path::PathBuf;

/// SP1 Groth16 VK v5.2.3 (arkworks format, 336 bytes)
///
/// Extracted from actual SP1 5.2 Groth16 proof using `cargo xtask extract-vk`.
/// This VK matches the SP1 SDK version 5.2 and will correctly verify proofs
/// generated by the current SP1 prover.
const GROTH16_VK_5_2_ARK: &[u8] = &[
    0x48, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe2, 0xf2, 0x6d, 0xbe, 0xa2, 0x99, 0xf5, 0x22,
    0x3b, 0x64, 0x6c, 0xb1, 0xfb, 0x33, 0xea, 0xdb, 0x05, 0x9d, 0x94, 0x07, 0x55, 0x9d, 0x74, 0x41,
    0xdf, 0xd9, 0x02, 0xe3, 0xa7, 0x9a, 0x4d, 0x2d, 0xab, 0xb7, 0x3d, 0xc1, 0x7f, 0xbc, 0x13, 0x02,
    0x1e, 0x24, 0x71, 0xe0, 0xc0, 0x8b, 0xd6, 0x7d, 0x84, 0x01, 0xf5, 0x2b, 0x73, 0xd6, 0xd0, 0x74,
    0x83, 0x79, 0x4c, 0xad, 0x47, 0x78, 0x18, 0x0e, 0x0c, 0x06, 0xf3, 0x3b, 0xbc, 0x4c, 0x79, 0xa9,
    0xca, 0xde, 0xf2, 0x53, 0xa6, 0x80, 0x84, 0xd3, 0x82, 0xf1, 0x77, 0x88, 0xf8, 0x85, 0xc9, 0xaf,
    0xd1, 0x76, 0xf7, 0xcb, 0x2f, 0x03, 0x67, 0x89, 0xed, 0xf6, 0x92, 0xd9, 0x5c, 0xbd, 0xde, 0x46,
    0xdd, 0xda, 0x5e, 0xf7, 0xd4, 0x22, 0x43, 0x67, 0x79, 0x44, 0x5c, 0x5e, 0x66, 0x00, 0x6a, 0x42,
    0x76, 0x1e, 0x1f, 0x12, 0xef, 0xde, 0x00, 0x18, 0xc2, 0x12, 0xf3, 0xae, 0xb7, 0x85, 0xe4, 0x97,
    0x12, 0xe7, 0xa9, 0x35, 0x33, 0x49, 0xaa, 0xf1, 0x25, 0x5d, 0xfb, 0x31, 0xb7, 0xbf, 0x60, 0x72,
    0x3a, 0x48, 0x0d, 0x92, 0x93, 0x93, 0x8e, 0x19, 0xed, 0x22, 0x01, 0xfb, 0xbf, 0x36, 0xd7, 0x27,
    0xb3, 0x63, 0x7a, 0x77, 0x76, 0x3b, 0x3d, 0xf8, 0xb8, 0xe4, 0x28, 0x4d, 0x35, 0x27, 0xaf, 0x2c,
    0xfe, 0x37, 0x0c, 0xba, 0xf4, 0x41, 0xff, 0x03, 0xe6, 0x74, 0x5f, 0x84, 0x69, 0x82, 0x99, 0x21,
    0x45, 0x02, 0x20, 0xc0, 0x0c, 0x5e, 0x86, 0xe0, 0x36, 0xd2, 0x46, 0x9b, 0xcc, 0x1e, 0xf0, 0x21,
    0x5f, 0x67, 0x15, 0xe7, 0x8d, 0xcb, 0xc7, 0x9c, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x8e, 0x75, 0xa9, 0x8a, 0xb5, 0x28, 0x1d, 0x45, 0x4c, 0x73, 0xdb, 0x33, 0x92, 0x77, 0x24, 0xf5,
    0xeb, 0x43, 0x37, 0xcd, 0x94, 0xa6, 0xa0, 0x4e, 0x8a, 0xad, 0xb0, 0xaf, 0x1c, 0x1e, 0x09, 0x26,
    0x4c, 0xfb, 0x51, 0x89, 0xc4, 0xc1, 0x37, 0xe5, 0x55, 0x87, 0x87, 0xec, 0xc6, 0x36, 0xed, 0x50,
    0xa7, 0xcc, 0x90, 0xd0, 0x27, 0xc2, 0x07, 0x26, 0x5d, 0xa2, 0x3d, 0xfd, 0xd0, 0x3f, 0x1c, 0x06,
    0x1c, 0xe7, 0x29, 0xd1, 0x4f, 0x63, 0x20, 0xe0, 0xde, 0x28, 0x60, 0xa1, 0x51, 0xec, 0xfd, 0x4f,
    0xec, 0xb2, 0xd0, 0xea, 0xe2, 0xe0, 0xe0, 0x7f, 0x81, 0x79, 0x8a, 0x38, 0x41, 0xb2, 0xea, 0x04,
];
use std::process::Command;
use std::str::FromStr;

use anyhow::{Context, Result, anyhow};
use clap::Parser;
use client_blockchain_sui::DeploymentInfo;
use shared_crypto::intent::Intent;
use sui_json_rpc_types::{SuiTransactionBlockEffectsAPI, SuiTransactionBlockResponseOptions};
use sui_keys::keystore::{AccountKeystore, FileBasedKeystore};
use sui_sdk::SuiClientBuilder;
use sui_types::base_types::ObjectID;
use sui_types::programmable_transaction_builder::ProgrammableTransactionBuilder;
use sui_types::quorum_driver_types::ExecuteTransactionRequestType;
use sui_types::transaction::{Command as MoveCommand, Transaction, TransactionData};

/// Setup Sui deployment (register VK, etc.)
#[derive(Debug, Parser)]
pub struct Setup {
    /// Network to setup (testnet, mainnet, local)
    #[arg(short, long, default_value = "testnet")]
    pub network: String,

    /// Gas budget for transactions (in MIST)
    #[arg(short, long, default_value = "50000000")]
    pub gas_budget: u64,

    /// Skip VK registration
    #[arg(long)]
    pub skip_vk: bool,
}

impl Setup {
    /// Execute the setup command.
    pub fn execute(&self) -> Result<()> {
        // Run async setup in blocking context
        tokio::runtime::Runtime::new()?.block_on(self.execute_async())
    }

    /// Async implementation of setup.
    async fn execute_async(&self) -> Result<()> {
        println!("üîß Setting up Sui deployment for {}...", self.network);
        println!();

        // Load deployment info from environment
        let mut deployment_info = match DeploymentInfo::from_env() {
            Ok(info) => {
                if info.network != self.network {
                    return Err(anyhow!(
                        "Network mismatch: .env has '{}' but --network specified '{}'",
                        info.network,
                        self.network
                    ));
                }
                info
            }
            Err(e) => {
                return Err(anyhow!(
                    "Failed to load deployment info from .env: {}. \
                     Please ensure SUI_NETWORK and SUI_PACKAGE_ID are set in .env file.",
                    e
                ));
            }
        };

        println!("üì¶ Package ID: {}", deployment_info.package_id);
        println!();

        // Register VK if not skipped
        if !self.skip_vk {
            if deployment_info.vk_object_id.is_some() {
                println!("‚ö†Ô∏è  VK already registered. Skipping VK registration.");
                println!(
                    "   VK Object ID: {}",
                    deployment_info.vk_object_id.as_ref().unwrap()
                );
            } else {
                let vk_object_id = self.register_vk(&deployment_info.package_id).await?;
                deployment_info.set_vk_object_id(vk_object_id.clone());

                // Save updated deployment info to .env
                deployment_info
                    .save_to_env()
                    .context("Failed to save updated deployment info to .env")?;

                println!();
                println!("‚úÖ VK registered successfully!");
                println!("   VK Object ID: {}", vk_object_id);
            }
        }

        println!();
        println!("üéâ Setup complete!");
        println!();
        println!("Deployment info saved to .env:");
        println!("  SUI_NETWORK={}", deployment_info.network);
        println!("  SUI_PACKAGE_ID={}", deployment_info.package_id);
        if let Some(vk_object_id) = &deployment_info.vk_object_id {
            println!("  SUI_VK_OBJECT_ID={}", vk_object_id);
        }

        Ok(())
    }

    /// Register verifying key on-chain.
    async fn register_vk(&self, package_id: &str) -> Result<String> {
        println!("üìù Registering verifying key...");
        println!("   ‚úÖ Using SP1 Groth16 VK v5.2.3 (extracted from actual proof)");
        println!();

        // Use SP1 5.2 VK extracted from actual Groth16 proof
        // This VK is already in arkworks compressed format, no conversion needed
        let vk_bytes = GROTH16_VK_5_2_ARK.to_vec();
        println!("   VK size: {} bytes (arkworks format)", vk_bytes.len());

        // Connect to Sui network
        let rpc_url = self.get_rpc_url();
        println!("   Connecting to: {}", rpc_url);

        let sui_client = SuiClientBuilder::default()
            .build(&rpc_url)
            .await
            .context("Failed to connect to Sui RPC")?;

        // Load keystore
        let keystore_path = self.keystore_path()?;
        let keystore =
            FileBasedKeystore::load_or_create(&keystore_path).context("Failed to load keystore")?;

        // Get active address
        let active_address = if let Ok(alias) = std::env::var("SUI_ACTIVE_ALIAS") {
            *keystore
                .addresses_with_alias()
                .iter()
                .find(|(_, a)| a.alias == alias)
                .ok_or_else(|| anyhow!("Address with alias '{}' not found", alias))?
                .0
        } else {
            *keystore
                .addresses()
                .first()
                .ok_or_else(|| anyhow!("No addresses in keystore"))?
        };

        println!("   Using address: {}", active_address);

        // Build programmable transaction to call create_verifying_key
        let package_obj_id = ObjectID::from_str(package_id).context("Invalid package ID")?;

        let mut pt_builder = ProgrammableTransactionBuilder::new();

        // Convert VK bytes to vector<u8> argument
        let vk_arg = pt_builder.pure(vk_bytes)?;

        // Version number: 50203 (representing 5.2.3 as 5*10000 + 2*100 + 3)
        let version_arg = pt_builder.pure(50203u64)?;

        // Call proof_verifier::create_verifying_key
        pt_builder.command(MoveCommand::move_call(
            package_obj_id,
            "proof_verifier".parse()?,
            "create_verifying_key".parse()?,
            vec![],                    // type arguments
            vec![vk_arg, version_arg], // arguments
        ));

        let pt = pt_builder.finish();

        // Build transaction data
        let gas_price = sui_client.read_api().get_reference_gas_price().await?;

        let gas_coins = sui_client
            .coin_read_api()
            .get_coins(active_address, None, None, None)
            .await?
            .data;

        if gas_coins.is_empty() {
            return Err(anyhow!(
                "No gas coins available for address {}",
                active_address
            ));
        }

        let gas_coin = gas_coins[0].object_ref();

        let tx_data = TransactionData::new_programmable(
            active_address,
            vec![gas_coin],
            pt,
            self.gas_budget,
            gas_price,
        );

        // Sign transaction
        let signature = keystore
            .sign_secure(&active_address, &tx_data, Intent::sui_transaction())
            .await?;

        println!("   Submitting transaction...");

        let tx = Transaction::from_data(tx_data, vec![signature]);

        let response = sui_client
            .quorum_driver_api()
            .execute_transaction_block(
                tx,
                SuiTransactionBlockResponseOptions::full_content(),
                Some(ExecuteTransactionRequestType::WaitForLocalExecution),
            )
            .await
            .context("Failed to execute VK registration transaction")?;

        println!("   Transaction digest: {}", response.digest);

        // Extract VK object ID from effects
        // For shared objects created by entry functions, check effects.created()
        let effects = response
            .effects
            .ok_or_else(|| anyhow!("No effects in response"))?;

        // Verify transaction succeeded
        if !effects.status().is_ok() {
            return Err(anyhow!(
                "VK registration transaction failed: {:?}",
                effects.status()
            ));
        }

        // Get created objects from effects
        let created = effects.created();
        if created.is_empty() {
            return Err(anyhow!("No objects created by VK registration transaction"));
        }

        // Return the first created object (should be our shared VerifyingKey)
        Ok(created[0].object_id().to_string())
    }

    /// Get RPC URL for the network.
    fn get_rpc_url(&self) -> String {
        match self.network.as_str() {
            "mainnet" => "https://fullnode.mainnet.sui.io:443".to_string(),
            "testnet" => "https://fullnode.testnet.sui.io:443".to_string(),
            "local" => "http://127.0.0.1:9000".to_string(),
            _ => "https://fullnode.testnet.sui.io:443".to_string(),
        }
    }

    /// Get Sui keystore path.
    fn keystore_path(&self) -> Result<PathBuf> {
        let home = directories::BaseDirs::new()
            .ok_or_else(|| anyhow!("Could not determine home directory"))?
            .home_dir()
            .to_path_buf();
        Ok(home.join(".sui").join("sui_config").join("sui.keystore"))
    }

    /// Switch to the target network.
    #[allow(dead_code)]
    fn switch_network(&self) -> Result<()> {
        println!("üîÑ Switching to network: {}", self.network);

        let output = Command::new("sui")
            .args(["client", "switch", "--env", &self.network])
            .output()
            .context(format!("Failed to switch to network: {}", self.network))?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow!(
                "Failed to switch to network {}: {}",
                self.network,
                stderr
            ));
        }

        Ok(())
    }
}
