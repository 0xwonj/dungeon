# RISC0 zkVM 3.0 Integration Guide

This document provides a comprehensive guide to integrating RISC0 zkVM into the dungeon project.

## Table of Contents

1. [Core Concepts](#core-concepts)
2. [Guest/Host Programming Model](#guesthost-programming-model)
3. [Build System](#build-system)
4. [Proof Generation & Verification APIs](#proof-generation--verification-apis)
5. [Development Workflow](#development-workflow)
6. [Dungeon Project Integration](#dungeon-project-integration)

---

## Core Concepts

### Architecture

RISC0 zkVM follows a clear separation between trusted and untrusted code:

- **Guest Program**: RISC-V (riscv32im) binary compiled to run inside the zkVM
- **Host Program**: Untrusted agent that launches the zkVM and generates proofs
- **Receipt**: Proof of execution containing:
  - **Journal**: Public outputs of the computation
  - **Seal**: Cryptographic attestation (opaque blob)

### Core Principle

> "The RISC Zero zkVM is a RISC-V virtual machine that produces zero-knowledge proofs of code it executes."

The zkVM allows you to prove correct execution of arbitrary Rust code, enabling zero-knowledge applications that leverage existing Rust packages.

---

## Guest/Host Programming Model

### Guest Program

The guest program runs inside the zkVM and has access to a minimal environment API.

**Example: methods/guest/src/main.rs**

```rust
use risc0_zkvm::guest::env;

fn main() {
    // Read private inputs from host
    let a: u64 = env::read();
    let b: u64 = env::read();

    // Validate inputs
    if a == 1 || b == 1 {
        panic!("Trivial factors");
    }

    // Perform computation
    let product = a.checked_mul(b).expect("Integer overflow");

    // Commit public result to journal
    env::commit(&product);
}
```

**Guest Characteristics:**
- Uses `risc0-zkvm` crate with `default-features = false`
- `env::read()`: Reads data sent by host (private inputs)
- `env::commit()`: Writes public results to journal
- Compiled to RISC-V binary (riscv32im-risc0-zkvm-elf)
- No I/O, no floating point, no non-determinism

### Host Program

The host program constructs the execution environment, runs the prover, and extracts results.

**Example: src/lib.rs**

```rust
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};

pub fn multiply(a: u64, b: u64) -> (Receipt, u64) {
    // 1. Create ExecutorEnv - pass inputs to guest
    let env = ExecutorEnv::builder()
        .write(&a)  // First env::read() in guest
        .write(&b)  // Second env::read() in guest
        .build()
        .unwrap();

    // 2. Get prover and generate proof
    let prover = default_prover();
    let receipt = prover.prove(env, MULTIPLY_ELF).unwrap().receipt;

    // 3. Extract result from journal
    let c: u64 = receipt.journal.decode().expect("Journal decoding failed");

    (receipt, c)
}

fn main() {
    let (receipt, result) = multiply(17, 23);

    // 4. Verify receipt
    receipt.verify(MULTIPLY_ID).expect("Verification failed");

    println!("Result: {}", result);
}
```

**Host Characteristics:**
- `ExecutorEnv::builder()`: Pass inputs to guest
- `default_prover()`: Get default prover implementation
- `prover.prove(env, ELF)`: Generate proof
- `receipt.journal.decode()`: Extract public outputs
- `receipt.verify(IMAGE_ID)`: Verify proof integrity

---

## Build System

### Project Structure

```
my_project/
├── Cargo.toml          # Workspace configuration
├── build.rs            # Builds guest ELF and generates ImageID
├── src/
│   ├── lib.rs          # Host code
│   └── main.rs         # Entry point
└── methods/
    └── guest/
        ├── Cargo.toml  # Guest dependencies
        └── src/
            └── main.rs # Guest program
```

### build.rs

```rust
fn main() {
    risc0_build::embed_methods();
}
```

### Root Cargo.toml

```toml
[build-dependencies]
risc0-build = "3.0"

[dependencies]
risc0-zkvm = "3.0"

[package.metadata.risc0]
methods = ["methods/guest"]  # Path to guest code
```

### Guest Cargo.toml

**IMPORTANT:** Guest must disable default features.

```toml
[package]
name = "guest"
version = "0.1.0"
edition = "2021"

[dependencies]
risc0-zkvm = { version = "3.0", default-features = false }
```

### Generated Code

The build script generates constants in `OUT_DIR/methods.rs`:

```rust
// src/lib.rs
include!(concat!(env!("OUT_DIR"), "/methods.rs"));

// Auto-generated by risc0-build:
// - methods::MULTIPLY_ELF (guest binary as &[u8])
// - methods::MULTIPLY_ID (ImageID for verification)
```

**Naming Convention:**
- Guest binary named `multiply` generates:
  - `methods::MULTIPLY_ELF`
  - `methods::MULTIPLY_ID`

---

## Proof Generation & Verification APIs

### Prover Implementations

1. **DefaultProver**: Local proof generation (requires 16GB+ RAM)
2. **BonsaiProver**: Remote proving service
3. **DevModeProver**: Development/testing mode (no real proofs)
4. **ExternalProver**: Uses external `r0vm` process

### ExecutorEnv Builder API

```rust
let env = ExecutorEnv::builder()
    .write(&data1)           // Send serialized data to guest
    .write(&data2)           // Multiple writes are sequenced
    .env_var("KEY", "value") // Set environment variables
    .build()?;
```

**Important:**
- Data must be serializable with risc0's custom codec
- Guest reads data in the same order it was written
- Type must match exactly between host write and guest read

### Receipt Structure

```rust
pub struct Receipt {
    pub journal: Journal,  // Public outputs
    pub seal: Seal,        // Cryptographic proof (opaque)
}
```

### Verification

**Host-side verification:**
```rust
receipt.verify(IMAGE_ID)?;
```

**Guest-side verification (recursive):**
```rust
use risc0_zkvm::guest::env;

env::verify(IMAGE_ID, journal_bytes)?;
```

### Serialization

Receipts can be serialized for storage or transmission:

```rust
use bincode;

// Serialize
let bytes = bincode::serialize(&receipt)?;

// Deserialize
let receipt: Receipt = bincode::deserialize(&bytes)?;
```

---

## Development Workflow

### 1. Fast Iteration (Dev Mode)

```bash
RISC0_DEV_MODE=1 cargo run --release
```

- Skips actual proof generation (very fast)
- Use during development for logic verification
- Produces receipts that pass verification in dev mode only

### 2. Proof Generation

```bash
RISC0_DEV_MODE=0 cargo run --release
```

- Generates real STARK proofs (seconds to minutes)
- Requires 16GB+ RAM for local proving
- Produces cryptographically valid receipts

### 3. Performance Profiling

```bash
RISC0_DEV_MODE=1 RUST_LOG=info RISC0_INFO=1 cargo run --release
```

- Shows executor statistics
- Useful for optimizing guest code
- Displays cycle counts and memory usage

### 4. Remote Proving (Bonsai)

```rust
use risc0_zkvm::BonsaiProver;

let prover = BonsaiProver::new("api_key")?;
let receipt = prover.prove(env, ELF)?;
```

- Offloads proving to remote infrastructure
- No local RAM requirements
- Requires API key and network access

---

## Dungeon Project Integration

### Architecture Overview

```text
┌─────────────────────────────────────────────────────────┐
│                     ProverWorker                        │
│  (crates/runtime/src/workers/prover.rs)                │
└─────────────────┬───────────────────────────────────────┘
                  │
                  │ calls
                  ▼
┌─────────────────────────────────────────────────────────┐
│               Risc0Prover (Host)                        │
│  (crates/zk/src/zkvm/risc0.rs)                         │
│  - Builds ExecutorEnv                                   │
│  - Calls default_prover().prove()                       │
│  - Serializes Receipt                                   │
└─────────────────┬───────────────────────────────────────┘
                  │
                  │ proves
                  ▼
┌─────────────────────────────────────────────────────────┐
│          Game Verifier Guest Program                    │
│  (crates/zk/methods/guest/src/main.rs)                 │
│  - Reads: before_state, action, after_state             │
│  - Executes: GameEngine::execute(action)                │
│  - Verifies: result matches expected                    │
│  - Commits: delta to journal                            │
└─────────────────────────────────────────────────────────┘
```

### Implementation Steps

#### 1. Create Guest Program

**File: crates/zk/methods/guest/Cargo.toml**

```toml
[package]
name = "game-verifier-guest"
version = "0.1.0"
edition = "2024"

[dependencies]
risc0-zkvm = { version = "3.0", default-features = false }
game-core = { path = "../../../game/core" }
serde = { version = "1.0", default-features = false }
```

**File: crates/zk/methods/guest/src/main.rs**

```rust
#![no_main]
#![no_std]

use risc0_zkvm::guest::env;
use game_core::{Action, GameState, GameEngine};

risc0_zkvm::guest::entry!(main);

fn main() {
    // Read inputs from host
    let before_state: GameState = env::read();
    let action: Action = env::read();
    let expected_after: GameState = env::read();

    // Execute action deterministically
    let engine = GameEngine::new(before_state.clone(), &oracle);
    let result = engine.execute(action)
        .expect("Action execution must succeed");

    // Verify state transition
    assert_eq!(
        result.state,
        expected_after,
        "State mismatch: proof cannot be generated for invalid transition"
    );

    // Commit public outputs to journal
    env::commit(&result.delta);
    env::commit(&result.state.clock);
}
```

**Key Considerations:**
- Guest must be `#![no_std]` (embedded environment)
- All dependencies must support `no_std`
- Oracle data must be embedded or passed via `env::read()`
- No I/O, no floating point, no randomness

#### 2. Update zk Crate Build System

**File: crates/zk/build.rs**

```rust
#[cfg(feature = "risc0")]
fn main() {
    risc0_build::embed_methods();
}

#[cfg(not(feature = "risc0"))]
fn main() {
    // No-op when risc0 feature is disabled
}
```

**File: crates/zk/Cargo.toml**

```toml
[package]
name = "zk"
version = "0.1.0"
edition = "2024"

[features]
default = ["risc0"]
risc0 = ["risc0-zkvm"]
zkvm = []  # Stub prover
sp1 = ["sp1-sdk"]
arkworks = [...]

[build-dependencies]
risc0-build = { version = "3.0", optional = true }

[dependencies]
game-core = { path = "../game/core" }
risc0-zkvm = { version = "3.0", optional = true }
bincode = "2"
serde = { version = "1.0", features = ["derive"] }
thiserror = "2"

[package.metadata.risc0]
methods = ["methods/guest"]
```

**File: crates/zk/src/lib.rs**

```rust
// Include generated methods
#[cfg(feature = "risc0")]
include!(concat!(env!("OUT_DIR"), "/methods.rs"));

// Re-export for convenience
#[cfg(feature = "risc0")]
pub use methods::{GAME_VERIFIER_ELF, GAME_VERIFIER_ID};
```

#### 3. Implement Risc0Prover

**File: crates/zk/src/zkvm/risc0.rs**

```rust
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use game_core::{Action, GameState, StateDelta};
use crate::{ProofBackend, ProofData, ProofError};
use super::ZkvmProver;

#[cfg(feature = "risc0")]
use crate::{GAME_VERIFIER_ELF, GAME_VERIFIER_ID};

/// RISC0 zkVM prover implementation.
pub struct Risc0Prover;

impl Risc0Prover {
    pub fn new() -> Self {
        Self
    }
}

impl Default for Risc0Prover {
    fn default() -> Self {
        Self::new()
    }
}

impl ZkvmProver for Risc0Prover {
    fn prove(
        &self,
        before_state: &GameState,
        action: &Action,
        after_state: &GameState,
        _delta: &StateDelta,
    ) -> Result<ProofData, ProofError> {
        // Build executor environment with inputs
        let env = ExecutorEnv::builder()
            .write(&before_state)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write before_state: {}", e)))?
            .write(&action)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write action: {}", e)))?
            .write(&after_state)
            .map_err(|e| ProofError::ZkvmError(format!("Failed to write after_state: {}", e)))?
            .build()
            .map_err(|e| ProofError::ZkvmError(format!("Failed to build ExecutorEnv: {}", e)))?;

        // Generate proof
        let prover = default_prover();
        let prove_info = prover
            .prove(env, GAME_VERIFIER_ELF)
            .map_err(|e| ProofError::ZkvmError(format!("Proof generation failed: {}", e)))?;

        let receipt = prove_info.receipt;

        // Verify receipt locally
        receipt
            .verify(GAME_VERIFIER_ID)
            .map_err(|e| ProofError::ZkvmError(format!("Receipt verification failed: {}", e)))?;

        // Serialize receipt
        let bytes = bincode::serialize(&receipt)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        Ok(ProofData {
            bytes,
            backend: ProofBackend::Risc0,
        })
    }

    fn verify(&self, proof: &ProofData) -> Result<bool, ProofError> {
        if proof.backend != ProofBackend::Risc0 {
            return Err(ProofError::ZkvmError(
                format!("Expected Risc0 backend, got {:?}", proof.backend)
            ));
        }

        // Deserialize receipt
        let receipt: Receipt = bincode::deserialize(&proof.bytes)
            .map_err(|e| ProofError::SerializationError(e.to_string()))?;

        // Verify receipt
        receipt
            .verify(GAME_VERIFIER_ID)
            .map_err(|e| ProofError::ZkvmError(format!("Verification failed: {}", e)))?;

        Ok(true)
    }
}
```

**File: crates/zk/src/zkvm/mod.rs**

```rust
mod stub;
pub use stub::StubZkvmProver;

#[cfg(feature = "risc0")]
mod risc0;
#[cfg(feature = "risc0")]
pub use risc0::Risc0Prover;

// Trait and common types...
pub trait ZkvmProver: Send + Sync {
    fn prove(
        &self,
        before_state: &GameState,
        action: &Action,
        after_state: &GameState,
        delta: &StateDelta,
    ) -> Result<ProofData, ProofError>;

    fn verify(&self, proof: &ProofData) -> Result<bool, ProofError>;
}

// Default prover based on features
#[cfg(feature = "risc0")]
pub use Risc0Prover as DefaultProver;

#[cfg(all(not(feature = "risc0"), feature = "zkvm"))]
pub use StubZkvmProver as DefaultProver;
```

#### 4. Update ProverWorker

**File: crates/runtime/src/workers/prover.rs**

```rust
async fn generate_proof_full_rebuild(
    &self,
    action: &Action,
    delta: &StateDelta,
    before_state: &GameState,
    after_state: &GameState,
) -> Result<ProofData, ProofError> {
    #[cfg(feature = "risc0")]
    {
        use zk::zkvm::{Risc0Prover, ZkvmProver};

        let prover = Risc0Prover::new();
        prover.prove(before_state, action, after_state, delta)
    }

    #[cfg(all(not(feature = "risc0"), feature = "zkvm"))]
    {
        use zk::zkvm::{StubZkvmProver, ZkvmProver};

        let prover = StubZkvmProver::new();
        prover.prove(before_state, action, after_state, delta)
    }

    #[cfg(not(any(feature = "risc0", feature = "zkvm")))]
    {
        // No proving backend available
        Ok(ProofData {
            bytes: vec![],
            backend: ProofBackend::None,
        })
    }
}
```

### Constraints and Requirements

#### GameState/Action Serialization

All game types must support serialization:

```rust
// game-core types must derive serde traits
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct GameState { ... }

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct Action { ... }
```

#### Determinism

GameEngine must be completely deterministic:
- No I/O operations
- No randomness (or use seeded RNG)
- No floating point arithmetic
- No time/clock access
- Same inputs always produce same outputs

#### Oracle Handling

Since guest cannot do I/O, oracle data must be:
1. Embedded in guest binary (for static content)
2. Passed via `env::read()` from host
3. Reconstructed from minimal inputs

**Option 1: Embed Static Content**
```rust
// In guest
const MAP_DATA: &[u8] = include_bytes!("../../../game/content/maps/dungeon.map");
```

**Option 2: Pass Oracle Data**
```rust
// In host
let env = ExecutorEnv::builder()
    .write(&before_state)
    .write(&action)
    .write(&after_state)
    .write(&oracle_data)  // Pass necessary oracle data
    .build()?;

// In guest
let oracle_data: OracleData = env::read();
```

#### Performance Considerations

- **Local Proving**: Requires 16GB+ RAM, takes seconds to minutes
- **Async Execution**: ProverWorker must not block simulation
- **Dev Mode**: Use `RISC0_DEV_MODE=1` during development
- **Bonsai**: Consider remote proving for production

### Testing Strategy

#### 1. Unit Tests (Dev Mode)

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_risc0_prover_dev_mode() {
        std::env::set_var("RISC0_DEV_MODE", "1");

        let prover = Risc0Prover::new();
        let proof = prover.prove(&before, &action, &after, &delta).unwrap();

        assert!(prover.verify(&proof).unwrap());
    }
}
```

#### 2. Integration Tests (Real Proofs)

```rust
#[cfg(test)]
mod integration_tests {
    #[test]
    #[ignore]  // Expensive test, run explicitly
    fn test_risc0_prover_real_proof() {
        std::env::set_var("RISC0_DEV_MODE", "0");

        // This will take seconds to minutes
        let prover = Risc0Prover::new();
        let proof = prover.prove(&before, &action, &after, &delta).unwrap();

        assert!(prover.verify(&proof).unwrap());
    }
}
```

#### 3. Runtime Integration Test

```rust
#[tokio::test]
async fn test_prover_worker_risc0() {
    let config = RuntimeConfig {
        enable_proving: true,
        ..Default::default()
    };

    let runtime = Runtime::builder()
        .config(config)
        .build()
        .await
        .unwrap();

    // Execute action and wait for proof event
    let mut events = runtime.subscribe_events();

    runtime.execute_action(action).await.unwrap();

    while let Ok(event) = events.recv().await {
        match event {
            GameEvent::ProofGenerated { proof_data, .. } => {
                assert_eq!(proof_data.backend, ProofBackend::Risc0);
                break;
            }
            _ => {}
        }
    }
}
```

---

## Additional Resources

- [RISC Zero Developer Docs](https://dev.risczero.com/api/zkvm/)
- [risc0-zkvm Crate Documentation](https://docs.rs/risc0-zkvm/)
- [RISC Zero GitHub Repository](https://github.com/risc0/risc0)
- [RISC Zero Rust Starter Template](https://github.com/risc0/risc0-rust-starter)
- [zkVM Tutorial: Hello World](https://dev.risczero.com/api/zkvm/tutorials/hello-world)
- [Understanding I/O in the zkVM](https://dev.risczero.com/api/zkvm/tutorials/io)
- [Guest Optimization Guide](https://dev.risczero.com/api/zkvm/optimization)

---

## Troubleshooting

### Common Issues

**1. "risc0-zkvm requires default-features = false in guest"**
- Ensure guest Cargo.toml has `default-features = false`

**2. "Out of memory during proof generation"**
- Use `RISC0_DEV_MODE=1` for development
- Use Bonsai for remote proving
- Increase system RAM to 16GB+

**3. "ImageID mismatch during verification"**
- Rebuild guest with `cargo clean && cargo build --release`
- Ensure guest code hasn't changed since proof generation

**4. "Journal decode failed"**
- Ensure types match exactly between guest commit and host decode
- Check that data is decoded in the same order as committed

**5. "Guest program panicked"**
- Check guest logs with `RUST_LOG=debug`
- Ensure all inputs are valid before proving
- Validate action before sending to prover

---

*Last updated: 2025-01-15*
